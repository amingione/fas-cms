--- 
import BaseLayout from '@layouts/BaseLayout.astro';
import ShopTopControls from '@components/shop/ShopTopControls';
import ShopSidebarFilters from '@/components/storefront/ShopSidebarFilters';
import { fetchProductsFromSanity, fetchCategories } from '@lib/sanity-utils';
import type { Product, Category } from '@lib/sanity-utils';
import ProductGrid from '@/components/storefront/ProductGrid.astro';
import FilterPanelMobile from '@/components/storefront/FilterPanelMobile.tsx';
import Pagination from '@/components/storefront/Pagination.astro';
import Breadcrumbs from '@/components/storefront/Breadcrumbs.astro';

export const prerender = false;

const PAGE_SIZE = 12;
const url = new URL(Astro.request.url);
const currentPage = parseInt(url.searchParams.get("page") || "1");
const currentCategory = url.searchParams.get("categorySlug") || url.searchParams.get("category") || "";
const start = (currentPage - 1) * PAGE_SIZE;
const end = start + PAGE_SIZE;
const sortParam = (url.searchParams.get('sort') || 'featured').toLowerCase();

function slugify(str: string): string {
  return str
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');
}

function normalizeFilterSlug(value: unknown): string {
  if (!value) return '';
  if (typeof value === 'string') return slugify(value);
  if (typeof value === 'object') {
    const obj = value as Record<string, unknown>;
    const candidates = [
      obj.slug,
      (obj.slug as any)?.current,
      obj.value,
      obj.label,
      obj.title,
      obj.name,
      obj._id
    ];
    for (const candidate of candidates) {
      if (typeof candidate === 'string' && candidate.trim()) return slugify(candidate);
    }
    try {
      const json = JSON.stringify(value);
      if (json && json !== '{}') return slugify(json);
    } catch {}
  }
  const str = String(value ?? '').trim();
  if (!str || str === '[object Object]') return '';
  return slugify(str);
}

function normalizeFilterLabel(value: unknown): string {
  if (!value) return '';
  if (typeof value === 'string') return value.trim();
  if (typeof value === 'object') {
    const obj = value as Record<string, unknown>;
    const labelCandidate =
      (typeof obj.title === 'string' ? obj.title : undefined) ??
      (typeof obj.label === 'string' ? obj.label : undefined) ??
      (typeof obj.name === 'string' ? obj.name : undefined) ??
      (typeof obj.value === 'string' ? obj.value : undefined) ??
      (typeof obj.slug === 'string' ? obj.slug : undefined) ??
      (typeof obj.slug === 'object' && obj.slug && typeof (obj.slug as any).current === 'string'
        ? (obj.slug as any).current
        : undefined);
    if (labelCandidate) return labelCandidate.trim();
  }
  const str = String(value ?? '').trim();
  if (!str || str === '[object Object]') return '';
  return str;
}

function fallbackFilterLabel(slug: string): string {
  return slug
    .split(/[-_]/g)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join(' ');
}

// Selected filter tags can come from ?filter=a&filter=b or ?filters=a,b
const rawFilters = [
  ...url.searchParams.getAll('filter'),
  ...(url.searchParams.get('filters')?.split(',') || [])
]
  .map((s) => normalizeFilterSlug(s))
  .filter(Boolean);
const selectedFilters: string[] = Array.from(new Set(rawFilters));

let allProducts: Product[] = [];
let categories: Category[] = [];

try {
  allProducts = await fetchProductsFromSanity({
    categorySlug: currentCategory || undefined,
  });
  categories = await fetchCategories();
} catch (err) {
  console.error("üî• Sanity Fetch Failed:", err);
}

const currentCategoryTitle = (currentCategory && categories.find((c:any) => c?.slug?.current === currentCategory)?.title) || 'All';

const canonical = (() => {
  try {
    const canonicalUrl = new URL(Astro.request.url);
    const params = new URLSearchParams();
    const keepKeys = ['categorySlug', 'category', 'page'];
    for (const key of keepKeys) {
      const value = url.searchParams.get(key);
      if (value) params.set(key, value);
    }
    const searchString = params.toString();
    canonicalUrl.search = searchString ? `?${searchString}` : '';
    canonicalUrl.hash = '';
    return canonicalUrl.toString();
  } catch {
    return undefined;
  }
})();

const metaTitle = currentCategory && currentCategoryTitle && currentCategoryTitle !== 'All'
  ? `${currentCategoryTitle} Performance Parts`
  : 'Performance Parts & Accessories';

const pageDescription = currentCategory && currentCategoryTitle && currentCategoryTitle !== 'All'
  ? `Shop ${currentCategoryTitle} parts, packages, and accessories engineered by F.A.S. Motorsports with in-house validation.`
  : 'Browse performance parts, billet hardware, and curated packages from F.A.S. Motorsports with real inventory and in-house support.';

const breadcrumbItems = [
  {
    '@type': 'ListItem',
    position: 1,
    name: 'Home',
    item: `${url.origin}/`
  },
  {
    '@type': 'ListItem',
    position: 2,
    name: 'Shop',
    item: `${url.origin}/shop`
  }
];

if (currentCategory && currentCategoryTitle && currentCategoryTitle !== 'All') {
  breadcrumbItems.push({
    '@type': 'ListItem',
    position: 3,
    name: currentCategoryTitle,
    item: canonical || `${url.origin}/shop`
  });
}

const breadcrumbStructuredData = {
  '@context': 'https://schema.org',
  '@type': 'BreadcrumbList',
  itemListElement: breadcrumbItems
};

// Build the available filters (category-aware)
// Build a slug -> title map and unique slug list
const filterTitleMap: Record<string, string> = {};
for (const p of allProducts as any[]) {
  const rawSlugs: any[] = Array.isArray(p?.filters)
    ? p.filters
    : Array.isArray(p?.filterTitles)
    ? p.filterTitles
    : [];
  const rawTitles: any[] = Array.isArray(p?.filterTitles) ? p.filterTitles : rawSlugs;
  rawSlugs.forEach((entry, idx) => {
    const slug = normalizeFilterSlug(entry);
    if (!slug) return;
    const titleSource = rawTitles[idx] ?? entry;
    const label = normalizeFilterLabel(titleSource) || fallbackFilterLabel(slug);
    if (!filterTitleMap[slug]) {
      filterTitleMap[slug] = label;
    }
  });
}
const uniqueFilters: string[] = Array.from(new Set(Object.keys(filterTitleMap)))
  .filter(Boolean)
  .sort();

// Apply selected filters (match-any). If none selected, keep all.
const filteredProducts: Product[] = selectedFilters.length
  ? allProducts.filter((p) => {
      const values: any[] = Array.isArray((p as any).filters)
        ? (p as any).filters
        : Array.isArray((p as any).filterTitles)
        ? (p as any).filterTitles
        : [];
      return values.some((f: any) => selectedFilters.includes(normalizeFilterSlug(f)));
    })
  : allProducts;

// Apply sorting before pagination
let sortedProducts: Product[] = [...filteredProducts];
try {
  switch (sortParam) {
    case 'price-low':
      sortedProducts.sort((a: any, b: any) => (Number(a?.price) || 0) - (Number(b?.price) || 0));
      break;
    case 'price-high':
      sortedProducts.sort((a: any, b: any) => (Number(b?.price) || 0) - (Number(a?.price) || 0));
      break;
    case 'name':
      sortedProducts.sort((a: any, b: any) => String(a?.title || '').localeCompare(String(b?.title || '')));
      break;
    case 'featured':
    default:
      sortedProducts.sort((a: any, b: any) => {
        const fa = Boolean((a as any)?.featured);
        const fb = Boolean((b as any)?.featured);
        if (fa && !fb) return -1;
        if (!fa && fb) return 1;
        return 0;
      });
  }
} catch {}

const totalCount = sortedProducts.length;
const totalPages = Math.ceil(totalCount / PAGE_SIZE);
const products = sortedProducts.slice(start, end);

const paginationLinks = [];
const maxVisiblePages = 5;
const pageGroup = Math.floor((currentPage - 1) / maxVisiblePages);
const startPage = pageGroup * maxVisiblePages + 1;
const endPage = Math.min(startPage + maxVisiblePages - 1, totalPages);

if (startPage > 1) {
  paginationLinks.push({ label: "‚Üê", page: startPage - 1 });
}
for (let page = startPage; page <= endPage; page++) {
  paginationLinks.push({ label: page.toString(), page });
}
if (endPage < totalPages) {
  paginationLinks.push({ label: "‚Üí", page: endPage + 1 });
}
---

<BaseLayout title={metaTitle} description={pageDescription} canonical={canonical}>
  <Fragment slot="head">
    <script type="application/ld+json">
      {JSON.stringify(breadcrumbStructuredData)}
    </script>
  </Fragment>
  <section class="max-w-full px-2 md:px-2 mt-11 pt-10">
    <div class="mb-6 mt-2 space-y-3">
      <Breadcrumbs items={[{ href: '/', label: 'Home' }, { href: '/shop', label: 'Shop' }, ...(currentCategory ? [{ label: currentCategoryTitle }] : [])]} />
      <div class="hidden md:block">
        <ShopTopControls
          client:load
          categories={categories}
          availableFilters={uniqueFilters}
          filterTitleMap={filterTitleMap}
          currentCategory={currentCategory}
          selectedFilters={selectedFilters}
        />
      </div>
      <div class="md:hidden">
        <FilterPanelMobile
          client:load
          categories={categories}
          filters={uniqueFilters}
          filterTitleMap={filterTitleMap}
          selectedCategory={currentCategory}
          selectedFilters={selectedFilters}
        />
      </div>
    </div>

    <div class="flex flex-col md:flex-row gap-0 pt-8">
      <aside class="relative w-full md:w-1/4 hidden md:block pr-4">
        <ShopSidebarFilters
          client:load
          categories={categories}
          availableFilters={uniqueFilters}
          filterTitleMap={filterTitleMap}
          currentCategory={currentCategory}
          selectedFilters={selectedFilters}
        />
      </aside>

      <div class="justify-between px-3 w-full md:w-full">
        <ProductGrid products={products} view={(url.searchParams.get('view') || 'grid') as 'grid' | 'list'} />
      </div>
    </div>

    <Pagination currentPage={currentPage} totalPages={Math.max(1, totalPages)} />
  </section>

  
  <!-- Client components handle filter interactions and URL updates -->

  <style>
    #pagination a:hover {
      color: white !important;
    }

    /* Explicitly set text color to white on hover for category links */
    #category-sidebar a:hover {
      color: #ffffff !important;
    }

    /* Remove legacy mobile flex that forced side-by-side groups inside the sheet */
  </style>
  <script is:inline>
    (function () {
      function showToast(message) {
        try {
          const toast = document.createElement("div");
          toast.textContent = String(message || "Added to cart");
          toast.style.position = "fixed";
          toast.style.bottom = "20px";
          toast.style.right = "20px";
          toast.style.background = "rgba(255,255,255,0.9)"; // match slug page
          toast.style.color = "#16a34a"; // green text to match slug page
          toast.style.padding = "10px 16px";
          toast.style.borderRadius = "6px";
          toast.style.boxShadow = "0 2px 6px rgba(0,0,0,0.3)";
          toast.style.zIndex = "9999";
          document.body.appendChild(toast);
          setTimeout(() => {
            toast.style.transition = "opacity 0.5s";
            toast.style.opacity = "0";
            setTimeout(() => toast.remove(), 500);
          }, 2000);
        } catch {}
      }

      // Expose for other components (e.g., ProductCard) to call if needed
      try { window.showToast = showToast; } catch {}

      // If the product cards dispatch a cart event, echo a toast here too
      window.addEventListener('cartUpdated', (ev) => {
        try {
          const cart = (ev && ev.detail) || [];
          const last = Array.isArray(cart) ? cart[cart.length - 1] : null;
          const name = last && last.name ? last.name : 'Item';
          showToast(`${name} added to cart`);
        } catch {}
      });
    })();
  </script>
</BaseLayout>
