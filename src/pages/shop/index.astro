--- 
import BaseLayout from '@layouts/BaseLayout.astro';
import ShopTopControls from '@components/shop/ShopTopControls';
import ShopSidebarFilters from '@/components/storefront/ShopSidebarFilters';
import { fetchProductsFromSanity, fetchCategories } from '@lib/sanity-utils';
import type { Product, Category } from '@lib/sanity-utils';
import ProductGrid from '@/components/storefront/ProductGrid.astro';
import FilterPanelMobile from '@/components/storefront/FilterPanelMobile.tsx';
import Pagination from '@/components/storefront/Pagination.astro';
import Breadcrumbs from '@/components/storefront/Breadcrumbs.astro';

export const prerender = false;

const PAGE_SIZE = 12;
const url = new URL(Astro.request.url);
const currentPage = parseInt(url.searchParams.get("page") || "1");
const currentCategory = url.searchParams.get("categorySlug") || url.searchParams.get("category") || "";
const start = (currentPage - 1) * PAGE_SIZE;
const end = start + PAGE_SIZE;
const sortParam = (url.searchParams.get('sort') || 'featured').toLowerCase();

// Selected filter tags can come from ?filter=a&filter=b or ?filters=a,b
const rawFilters = [
  ...url.searchParams.getAll("filter"),
  ...(url.searchParams.get("filters")?.split(",") || [])
]
  .map((s) => s.trim().toLowerCase())
  .filter(Boolean);
const selectedFilters: string[] = Array.from(new Set(rawFilters));

let allProducts: Product[] = [];
let categories: Category[] = [];

try {
  allProducts = await fetchProductsFromSanity({
    categorySlug: currentCategory || undefined,
  });
  categories = await fetchCategories();
} catch (err) {
  console.error("üî• Sanity Fetch Failed:", err);
}

const currentCategoryTitle = (currentCategory && categories.find((c:any) => c?.slug?.current === currentCategory)?.title) || 'All';

// Build the available filters (category-aware)
const uniqueFilters: string[] = Array.from(
  new Set(
    allProducts.flatMap((p) => Array.isArray((p as any).filters) ? (p as any).filters.map((f: any) => String(f).toLowerCase()) : [])
  )
).sort();

// Apply selected filters (match-any). If none selected, keep all.
const filteredProducts: Product[] = selectedFilters.length
  ? allProducts.filter((p) => Array.isArray((p as any).filters) && (p as any).filters.some((f: any) => selectedFilters.includes(String(f).toLowerCase())))
  : allProducts;

// Apply sorting before pagination
let sortedProducts: Product[] = [...filteredProducts];
try {
  switch (sortParam) {
    case 'price-low':
      sortedProducts.sort((a: any, b: any) => (Number(a?.price) || 0) - (Number(b?.price) || 0));
      break;
    case 'price-high':
      sortedProducts.sort((a: any, b: any) => (Number(b?.price) || 0) - (Number(a?.price) || 0));
      break;
    case 'name':
      sortedProducts.sort((a: any, b: any) => String(a?.title || '').localeCompare(String(b?.title || '')));
      break;
    case 'featured':
    default:
      sortedProducts.sort((a: any, b: any) => {
        const fa = Boolean((a as any)?.featured);
        const fb = Boolean((b as any)?.featured);
        if (fa && !fb) return -1;
        if (!fa && fb) return 1;
        return 0;
      });
  }
} catch {}

const totalCount = sortedProducts.length;
const totalPages = Math.ceil(totalCount / PAGE_SIZE);
const products = sortedProducts.slice(start, end);

const paginationLinks = [];
const maxVisiblePages = 5;
const pageGroup = Math.floor((currentPage - 1) / maxVisiblePages);
const startPage = pageGroup * maxVisiblePages + 1;
const endPage = Math.min(startPage + maxVisiblePages - 1, totalPages);

if (startPage > 1) {
  paginationLinks.push({ label: "‚Üê", page: startPage - 1 });
}
for (let page = startPage; page <= endPage; page++) {
  paginationLinks.push({ label: page.toString(), page });
}
if (endPage < totalPages) {
  paginationLinks.push({ label: "‚Üí", page: endPage + 1 });
}
---

<BaseLayout>
  <section class="max-w-7xl mx-auto px-4 md:px-6 mt-11 pt-10">
    <div class="mb-6 space-y-3">
      <Breadcrumbs items={[{ href: '/', label: 'Home' }, { href: '/shop', label: 'Shop' }, ...(currentCategory ? [{ label: currentCategoryTitle }] : [])]} />
      <div class="hidden md:block">
        <ShopTopControls
          client:load
          categories={categories}
          availableFilters={uniqueFilters}
          currentCategory={currentCategory}
          selectedFilters={selectedFilters}
        />
      </div>
      <div class="md:hidden">
        <FilterPanelMobile
          client:load
          categories={categories}
          filters={uniqueFilters}
          selectedCategory={currentCategory}
          selectedFilters={selectedFilters}
        />
      </div>
    </div>

    <div class="flex flex-col md:flex-row gap-0 pt-8">
      <aside class="w-full md:w-1/4 hidden md:block pr-4">
        <ShopSidebarFilters
          client:load
          categories={categories}
          availableFilters={uniqueFilters}
          currentCategory={currentCategory}
          selectedFilters={selectedFilters}
        />
      </aside>

      <div class="justify-between w-full md:w-3/4">
        <ProductGrid products={products} view={(url.searchParams.get('view') || 'grid') as 'grid' | 'list'} />
      </div>
    </div>

    <Pagination currentPage={currentPage} totalPages={Math.max(1, totalPages)} />
  </section>

  
  <!-- Client components handle filter interactions and URL updates -->

  <style>
    #pagination a:hover {
      color: white !important;
    }

    /* Explicitly set text color to white on hover for category links */
    #category-sidebar a:hover {
      color: #ffffff !important;
    }

    /* Remove legacy mobile flex that forced side-by-side groups inside the sheet */
  </style>
  <script is:inline>
    (function () {
      function showToast(message) {
        try {
          const toast = document.createElement("div");
          toast.textContent = String(message || "Added to cart");
          toast.style.position = "fixed";
          toast.style.bottom = "20px";
          toast.style.right = "20px";
          toast.style.background = "rgba(255,255,255,0.9)"; // match slug page
          toast.style.color = "#16a34a"; // green text to match slug page
          toast.style.padding = "10px 16px";
          toast.style.borderRadius = "6px";
          toast.style.boxShadow = "0 2px 6px rgba(0,0,0,0.3)";
          toast.style.zIndex = "9999";
          document.body.appendChild(toast);
          setTimeout(() => {
            toast.style.transition = "opacity 0.5s";
            toast.style.opacity = "0";
            setTimeout(() => toast.remove(), 500);
          }, 2000);
        } catch {}
      }

      // Expose for other components (e.g., ProductCard) to call if needed
      try { window.showToast = showToast; } catch {}

      // If the product cards dispatch a cart event, echo a toast here too
      window.addEventListener('cartUpdated', (ev) => {
        try {
          const cart = (ev && ev.detail) || [];
          const last = Array.isArray(cart) ? cart[cart.length - 1] : null;
          const name = last && last.name ? last.name : 'Item';
          showToast(`${name} added to cart`);
        } catch {}
      });
    })();
  </script>
</BaseLayout>
