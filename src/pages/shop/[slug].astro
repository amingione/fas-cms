---
import BaseLayout from '../../layouts/BaseLayout.astro';
import {
  coercePriceToNumber,
  getProductBySlug,
  getRelatedProducts,
  getUpsellProducts,
  optimizeSanityImageUrl,
  type Product
} from '../../lib/sanity-utils';
import PortableTextRenderer from "../../components/PortableTextRenderer.jsx";
import SlugCarousel from '@/components/SlugCarousel.astro';
import { Image as AstroImage } from '@astrojs/image/components';
import { inlineFieldAttrs, inlineObjectId } from '@lib/content.ts';
import ServiceDisclaimerNotice from '@/components/storefront/ServiceDisclaimerNotice.tsx';
import InfoTabs from '@/components/shop/InfoTabs';
import productPageScript from '../../scripts/product-page.ts?raw';

export type KitItem = { item: string; quantity?: number };
export type VehicleCompat = { make?: string; model?: string; trim?: string };
export type SpecItem = { label?: string; name?: string; value?: string; detail?: string };
export type AttrItem = { key?: string; value?: string };

type FilterEntry =
  | string
  | {
      _id?: string;
      title?: string;
      label?: string;
      name?: string;
      value?: string;
      slug?: { current?: string } | string;
    };

export type ProductWithKit = Product & {
  includedInKit?: KitItem[];
  requiresPaintCode?: boolean;
  compatibleVehicles?: VehicleCompat[];
  tune?: { title?: string } | null;
  averageHorsepower?: number | null;
  specifications?: SpecItem[];
  attributes?: AttrItem[];
  filters?: FilterEntry[];
  categories?: { slug?: { current?: string } | string; title?: string }[];
  media?: any[];
};

type ProcessedProductImage = {
  originalUrl: string;
  webpUrl: string;
  thumbnailUrl: string;
  alt: string;
  fileName: string;
  width?: number;
  height?: number;
  aspectRatio?: number;
};

type FAQEntry = {
  question: string;
  answer: ContentDescriptor;
};

const slugify = (str: string): string =>
  String(str ?? '')
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');

const toSeoFileName = (productSlug: string, variant: string): string => {
  const normalizedProductSlug = slugify(productSlug || 'product');
  const normalizedVariant = slugify(variant || 'image');
  const base = [normalizedProductSlug, normalizedVariant].filter(Boolean).join('-') || 'product-image';
  return `${base}.webp`;
};

const withDownloadFileName = (url: string, fileName: string): string => {
  try {
    const parsed = new URL(url);
    if (fileName) {
      parsed.searchParams.set('dl', fileName);
    }
    return parsed.toString();
  } catch {
    return url;
  }
};

const sanitizeAnalyticsPayload = (payload: Record<string, unknown>) =>
  Object.fromEntries(
    Object.entries(payload).filter(([, value]) => value !== undefined && value !== null && value !== '')
  );

const buildAnalyticsParams = (payload: Record<string, unknown>) =>
  JSON.stringify(sanitizeAnalyticsPayload(payload));

const buildProductImageAlt = (explicitAlt: unknown, fallback: string, index: number): string => {
  const normalizedExplicit = collapseSpaces(toPlainText(explicitAlt ?? ''));
  const base = normalizedExplicit || fallback;
  const detailLabel = index === 0 ? 'main product image' : `detail image ${index + 1}`;
  return collapseSpaces(`${base} ${detailLabel} | F.A.S. Motorsports`);
};

const normalizeFilterSlug = (value: FilterEntry): string => {
  if (!value) return '';
  if (typeof value === 'string') return slugify(value);
  const candidates = [
    value.slug,
    typeof value.slug === 'object' && value.slug ? (value.slug as any).current : undefined,
    value.value,
    value.label,
    value.title,
    value.name,
    value._id
  ];
  for (const candidate of candidates) {
    if (typeof candidate === 'string' && candidate.trim()) return slugify(candidate);
  }
  try {
    const json = JSON.stringify(value);
    if (json && json !== '{}') return slugify(json);
  } catch {}
  return '';
};

const normalizeFilterLabel = (value: FilterEntry, fallbackSlug: string): string => {
  if (!value) return fallbackSlug;
  if (typeof value === 'string') return value.trim();
  const candidates = [
    value.title,
    value.label,
    value.name,
    value.value,
    value.slug,
    typeof value.slug === 'object' && value.slug ? (value.slug as any).current : undefined
  ];
  for (const candidate of candidates) {
    if (typeof candidate === 'string' && candidate.trim() && candidate !== '[object Object]') {
      return candidate.trim();
    }
  }
  return fallbackSlug
    .split(/[-_]/g)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join(' ');
};

const VEHICLE_DISCLAIMER_KEYWORDS = [
  'install service',
  'installation service',
  'install-only',
  'install only',
  'performance package',
  'performance packages',
  'power package',
  'power packages',
  'truck package',
  'truck packages'
];

const { slug } = Astro.params;
const disableImageProxyFlag =
  String(
    (import.meta.env.PUBLIC_DISABLE_IMAGE_PROXY as string | undefined) ??
      (import.meta.env.PUBLIC_DISABLE_IMAGE_OPTIMIZATION as string | undefined) ??
      ''
  )
    .trim()
    .toLowerCase() === 'true';
const enableProxyInDevFlag =
  String((import.meta.env.PUBLIC_ENABLE_IMAGE_PROXY_IN_DEV as string | undefined) ?? '')
    .trim()
    .toLowerCase() === 'true';
const useOptimizedImages = !disableImageProxyFlag && (import.meta.env.PROD || enableProxyInDevFlag);

const toPlainText = (input: any): string => {
  if (!input) return '';
  if (typeof input === 'string') return input;
  if (Array.isArray(input)) {
    return input
      .map((block) => {
        if (typeof block === 'string') return block;
        if (block && typeof block === 'object') {
          if (Array.isArray((block as any).children)) {
            return (block as any).children
              .map((child: any) => (typeof child?.text === 'string' ? child.text : ''))
              .join('');
          }
          if (typeof (block as any).text === 'string') return (block as any).text;
        }
        return '';
      })
      .join(' ');
  }
  if (typeof input === 'object') {
    const values = ['text', 'content', 'description']
      .map((key) => (input as any)?.[key])
      .filter(Boolean);
    if (values.length) return toPlainText(values);
  }
  return '';
};

const collapseSpaces = (value: unknown): string => {
  if (value == null) return '';
  return String(value).replace(/\s+/g, ' ').trim();
};

const META_DESCRIPTION_SUFFIX =
  'Shop high-performance installs and upgrades with F.A.S. Motorsports in Fort Myers, Florida.';
const META_DESCRIPTION_LIMIT = 155;

const truncateForMeta = (value: string, maxLength: number): string => {
  const normalized = collapseSpaces(value);
  if (normalized.length <= maxLength) return normalized;
  const truncated = normalized.slice(0, maxLength).replace(/[\s,;:.-]+$/g, '');
  return `${truncated}…`;
};

const hasRichContent = (value: unknown): boolean => collapseSpaces(toPlainText(value)).length > 0;

type ContentDescriptor =
  | { type: 'portable'; value: any[]; field?: string }
  | { type: 'text'; value: string; field?: string };

const describeContent = (value: unknown, field?: string): ContentDescriptor | null => {
  if (!hasRichContent(value)) return null;
  if (Array.isArray(value)) {
    return { type: 'portable', value, field };
  }
  return { type: 'text', value: collapseSpaces(toPlainText(value)), field };
};

const isContentDescriptor = (value: ContentDescriptor | null): value is ContentDescriptor =>
  value !== null;

const inlineAttrsFor = (field?: string): Record<string, any> => (field ? inlineFieldAttrs(field) : {});

const collectSeoStrings = (...values: unknown[]): string[] => {
  const results: string[] = [];
  const queue: unknown[] = values.slice();
  const visited = new Set<unknown>();
  while (queue.length) {
    const next = queue.shift();
    if (next === undefined || next === null) continue;
    if (visited.has(next)) continue;
    if (typeof next === 'string' || typeof next === 'number' || typeof next === 'boolean') {
      const normalized = collapseSpaces(String(next));
      if (normalized) results.push(normalized);
      continue;
    }
    if (Array.isArray(next)) {
      for (const item of next) {
        queue.push(item);
      }
      continue;
    }
    if (typeof next === 'object') {
      visited.add(next);
      const obj = next as Record<string, unknown>;
      const preferredKeys = [
        'fitmentYears',
        'primaryKeyword',
        'value',
        'label',
        'name',
        'title',
        'text',
        'content',
        'description',
        'subtitle',
        'body'
      ];
      let pushed = false;
      for (const key of preferredKeys) {
        if (key in obj) {
          queue.push(obj[key]);
          pushed = true;
        }
      }
      if (!pushed) {
        for (const value of Object.values(obj)) {
          queue.push(value);
        }
      }
    }
  }
  return results;
};

const escapeRegExp = (value: string): string => value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

const toTitleCase = (value: string): string => {
  return value
    .split(/([\s-/]+)/g)
    .map((segment) => {
      if (/^[\s-/]+$/.test(segment)) return segment;
      if (/^(TRX|F-150|F150|F\.A\.S\.|FAS|HEMI|HP|WHP|AWD|4WD|RWD|E85)$/i.test(segment)) {
        return segment.toUpperCase();
      }
      return segment.charAt(0).toUpperCase() + segment.slice(1).toLowerCase();
    })
    .join('')
    .replace(/F\.A\.S\./gi, 'F.A.S.');
};

const sanitizeFitmentPhrase = (value: string): string => {
  const withoutPipes = value.split(/[|•]/g)[0];
  const withoutParens = withoutPipes.replace(/\([^)]*\)/g, '');
  const trimmed = collapseSpaces(withoutParens.replace(/[:;-]+$/, ''));
  return trimmed.length > 60 ? collapseSpaces(trimmed.slice(0, 60)) : trimmed;
};

const extractFitmentPhraseFromText = (value: string): string | null => {
  const source = value.trim();
  if (!/\b(19|20)\d{2}\b/.test(source)) return null;

  const contextMatch = source.match(/((?:19|20)\d{2}(?:\s*(?:\+|[-–—]|to)\s*(?:19|20)?\d{2})?)([^,.\n;]*)/i);
  if (contextMatch) {
    const candidate = sanitizeFitmentPhrase(`${contextMatch[1]}${contextMatch[2] ?? ''}`);
    if (candidate) return candidate;
  }

  const plusMatch = source.match(/((?:19|20)\d{2})\s*\+/i);
  if (plusMatch) return sanitizeFitmentPhrase(`${plusMatch[1]}+`);

  const rangeMatch = source.match(/((?:19|20)\d{2})\s*(?:[-–—]|to)\s*((?:19|20)\d{2})/i);
  if (rangeMatch) return sanitizeFitmentPhrase(`${rangeMatch[1]}-${rangeMatch[2]}`);

  const singleMatch = source.match(/\b((?:19|20)\d{2})\b/);
  if (singleMatch) return sanitizeFitmentPhrase(singleMatch[1]);

  return null;
};

const deriveFitmentPhrase = (
  product: ProductWithKit | null,
  plainDescription: string,
  additionalCandidates: string[]
): string => {
  if (!product) return '';
  const directCandidates = collectSeoStrings(
    (product as any)?.seo?.fitmentYears,
    (product as any)?.seo?.fitment,
    (product as any)?.fitmentYears,
    (product as any)?.fitment,
    (product as any)?.fitmentRange,
    (product as any)?.seo?.fitmentText
  );

  const attributeCandidates = Array.isArray((product as any)?.attributes)
    ? (product as any).attributes.map((attr: any) => `${attr?.name ?? ''} ${attr?.value ?? ''}`)
    : [];
  const specificationCandidates = Array.isArray((product as any)?.specifications)
    ? (product as any).specifications.map((spec: any) => `${spec?.label ?? ''} ${spec?.value ?? ''}`)
    : [];
  const compatibilityCandidates = Array.isArray((product as any)?.compatibleVehicles)
    ? (product as any).compatibleVehicles.map((vehicle: any) =>
        [vehicle?.make, vehicle?.model, vehicle?.trim].filter(Boolean).join(' ')
      )
    : [];

  const searchPool = [
    ...directCandidates,
    ...attributeCandidates,
    ...specificationCandidates,
    ...compatibilityCandidates,
    plainDescription,
    (product as any)?.shortDescription,
    (product as any)?.title,
    ...additionalCandidates
  ];

  const seen = new Set<string>();
  for (const candidate of collectSeoStrings(searchPool)) {
    const match = extractFitmentPhraseFromText(candidate);
    if (!match) continue;
    const normalized = match.toLowerCase();
    if (seen.has(normalized)) continue;
    seen.add(normalized);
    return match;
  }
  return '';
};

const sanitizePrimaryKeyword = (value: string, productTitle: string): string => {
  const normalized = collapseSpaces(value)
    .replace(/F\.A\.S\.\s+Motorsports/gi, '')
    .replace(/FAS\s+Motorsports/gi, '')
    .replace(/vehicle not included/gi, '')
    .replace(new RegExp(escapeRegExp(productTitle), 'i'), '')
    .trim();
  return normalized ? toTitleCase(normalized) : '';
};

const derivePrimaryKeyword = (
  product: ProductWithKit | null,
  productTitle: string,
  categoryTitles: string[],
  productTypeSegments: string[],
  filterTokens: string[],
  fitmentPhrase: string,
  metaKeywordTokens: string[],
  isInstallOnly: boolean,
  isPerformanceParts: boolean
): string => {
  if (!product) return '';
  const directCandidates = collectSeoStrings(
    (product as any)?.seo?.primaryKeyword,
    (product as any)?.seo?.keyword,
    (product as any)?.primaryKeyword,
    (product as any)?.seo?.keyphrase,
    (product as any)?.seo?.targetKeyword
  );

  const fallbackCandidates = [
    ...categoryTitles,
    ...productTypeSegments,
    ...filterTokens,
    fitmentPhrase.replace(/^(?:19|20)\d{2}(?:\s*(?:\+|[-–—]|to)\s*(?:19|20)?\d{2})?\s*/i, ''),
    metaKeywordTokens[0],
    isInstallOnly ? 'Installation Service' : '',
    isPerformanceParts ? 'Performance Parts' : ''
  ];

  const candidates = [...directCandidates, ...fallbackCandidates];
  for (const candidate of candidates) {
    const cleaned = sanitizePrimaryKeyword(candidate, productTitle);
    if (!cleaned) continue;
    if (/motorsports/i.test(cleaned)) continue;
    if (cleaned.toLowerCase() === productTitle.toLowerCase()) continue;
    return cleaned;
  }
  return isInstallOnly ? 'Installation Service' : isPerformanceParts ? 'Performance Parts' : '';
};

const deriveBenefitsSummary = (
  product: ProductWithKit | null,
  plainDescription: string
): string => {
  if (!product) return '';
  const candidates = collectSeoStrings(
    (product as any)?.seo?.benefits,
    (product as any)?.seo?.highlights,
    (product as any)?.seo?.valueProps,
    (product as any)?.metaDescription,
    (product as any)?.shortDescription,
    plainDescription
  );

  for (const candidate of candidates) {
    const sentence = candidate.split(/[.!?]/).find((part) => part.trim().length > 20);
    const fallback = sentence || candidate;
    const cleaned = collapseSpaces(fallback);
    if (cleaned.length >= 20) {
      return cleaned.length > 120 ? collapseSpaces(cleaned.slice(0, 120)) : cleaned;
    }
  }
  return '';
};

const deriveCallToAction = (
  product: ProductWithKit | null,
  isInstallOnly: boolean,
  isPerformanceParts: boolean
): string => {
  const explicitCta = collectSeoStrings(
    (product as any)?.seo?.callToAction,
    (product as any)?.seo?.cta,
    (product as any)?.seo?.ctaText
  ).find((value) => value.length > 0);
  if (explicitCta) return explicitCta;
  if (isInstallOnly) return 'Schedule your install today.';
  if (isPerformanceParts) return 'Order your performance parts now.';
  return 'Shop now.';
};

const ensureDisclaimerMessaging = (value: string, message: string): string => {
  const base = collapseSpaces(value || '');
  if (!message) return base;
  const normalized = base.toLowerCase();
  if (normalized.includes('vehicle not included') || normalized.includes('vehicle is not included')) {
    return base;
  }
  const merged = `${base ? `${base} ` : ''}${message}`;
  return collapseSpaces(merged);
};

const requestUrl = new URL(Astro.request.url);
const slugSegments = Array.isArray(slug) ? slug : typeof slug === 'string' ? [slug] : [];
const slugValue = slugSegments.filter((segment): segment is string => typeof segment === 'string').pop() ?? '';
const defaultCanonical = `${requestUrl.origin}/shop/${slugValue}`;

const ensureAbsoluteUrl = (value?: string | null): string | undefined => {
  if (!value) return undefined;
  if (/^https?:/i.test(value)) return value;
  try {
    return new URL(value, requestUrl.origin).toString();
  } catch {
    return undefined;
  }
};

const resolveProductSlug = (item: Product | null | undefined): string => {
  const rawSlug = (item as any)?.slug;
  if (typeof rawSlug === 'string') return rawSlug;
  if (rawSlug && typeof rawSlug === 'object' && typeof rawSlug.current === 'string') {
    return rawSlug.current;
  }
  return '';
};

const buildProductListStructuredData = (items: Product[], listName: string): Record<string, any> | null => {
  if (!Array.isArray(items) || items.length === 0) return null;
  const itemListElement = items
    .map((item, index) => {
      if (!item) return null;
      const slugValue = resolveProductSlug(item);
      if (!slugValue) return null;
      const productUrl = `${requestUrl.origin}/shop/${slugValue}`;
      const images = Array.isArray((item as any)?.images)
        ? (item as any).images
            .map((image: any) => ensureAbsoluteUrl(image?.asset?.url || image?.url))
            .filter((value: string | undefined): value is string => Boolean(value))
        : [];
      const priceNumber = coercePriceToNumber((item as any)?.price);
      const offers = typeof priceNumber === 'number'
        ? {
            '@type': 'Offer',
            priceCurrency: 'USD',
            price: priceNumber.toFixed(2),
            availability: 'https://schema.org/InStock',
            url: productUrl,
            itemCondition: 'https://schema.org/NewCondition'
          }
        : undefined;
      return {
        '@type': 'ListItem',
        position: index + 1,
        url: productUrl,
        item: {
          '@type': 'Product',
          name: (item as any)?.title ?? undefined,
          image: images.length ? images : undefined,
          offers
        }
      };
    })
    .filter((entry): entry is NonNullable<typeof entry> => Boolean(entry));

  if (!itemListElement.length) return null;

  return {
    '@context': 'https://schema.org',
    '@type': 'ItemList',
    name: listName,
    itemListElement
  };
};

// Fetch product data based on the slug
let product: ProductWithKit | null = null;
let relatedProducts: Product[] = [];
let upsellProducts: Product[] = [];
let options: any[] = [];
let addOns: any[] = [];
let customs: any[] = [];
let variationOptions: any[] = [];
let plainDescription: string = '';
let seoTitle: string = 'Product';
let seoDesc: string | undefined;
let seoCanon: string | undefined = defaultCanonical;
let seoOg: string | undefined;
let productPriceNumber: number | undefined;
let baseProductTitle = 'Product';
let normalizedImageSlug = slugify(slugValue || baseProductTitle);
try {
  if (typeof slug !== 'string') {
    throw new Error('Product slug is missing or invalid.');
  }
  product = await getProductBySlug(slug);
  if (!product) {
    throw new Error(`Product with slug "${slug}" not found.`);
  }

  baseProductTitle = String((product as any)?.title || 'Product');

  const coercedBasePrice = coercePriceToNumber((product as any)?.price);
  productPriceNumber = typeof coercedBasePrice === 'number' ? coercedBasePrice : undefined;

  // Build inputs for auto-related / upsell
  const catIds = ((product as any).category || (product as any).categories || [])
    .map((c: any) => c?._id || c?._ref)
    .filter(Boolean);
  const tagFilters = Array.isArray((product as any).filters)
    ? (product as any).filters.map((entry: FilterEntry) => normalizeFilterSlug(entry)).filter(Boolean)
    : [];
  const basePrice = typeof productPriceNumber === 'number' ? productPriceNumber : undefined;

  // Auto-related and upsell
  relatedProducts = await getRelatedProducts(slug, catIds, tagFilters, 6);
  upsellProducts = await getUpsellProducts(slug, catIds, basePrice, 6);

  // ---- Options/Upgrades normalization (support multiple schema shapes) ----
  variationOptions = Array.isArray((product as any).variationOptions) ? (product as any).variationOptions : [];
  const optionsSources = [
    (product as any).options,
    (product as any).optionGroups,
    (product as any).variations
  ];
  options = (optionsSources.find((src) => Array.isArray(src) && src.length) || variationOptions || []) as any[];
  addOns  = ((product as any).addOns  || (product as any).upgrades     || (product as any).extras     || []) as any[];
  customs = ((product as any).customizations || (product as any).customOptions || []) as any[];
  // Normalize arrays and shapes to prevent null access during render
  options = Array.isArray(options)
    ? options
        .filter(Boolean)
        .map((g: any) => {
          if (!g || typeof g !== 'object') return null;

          // Sanity option schemas vary (values/items/sizes/etc.); pick the first populated shape
          const possibleArrays = [
            g.values,
            g.items,
            g.options,
            g.choices,
            g.sizes,
            g.variants,
            g.entries,
            g.variations,
            g.valueOptions
          ];

          const values = (possibleArrays.find((arr) => Array.isArray(arr) && arr.length) ?? []) as any[];

          return {
            ...g,
            key: g.key || g.name || g.title || 'option',
            title: g.title || g.name || 'Option',
            values
          };
        })
        .filter((group: any) => Array.isArray(group?.values) && group.values.length > 0)
    : [];

  if (options.length === 0 && Array.isArray(variationOptions) && variationOptions.length > 0) {
    options.push({
      key: 'variation',
      title: 'Options',
      values: variationOptions
    });
  }

  addOns = Array.isArray(addOns)
    ? addOns
        .filter(Boolean)
        .map((a: any) => {
          const label =
            (a?.label ||
              a?.title ||
              a?.name ||
              a?.value ||
              a?.id ||
              'Upgrade').toString();
          const value =
            (a?.value ||
              a?.label ||
              a?.title ||
              a?.name ||
              a?.id ||
              label).toString();
          const priceDelta =
            typeof a?.priceDelta === 'number'
              ? a.priceDelta
              : typeof a?.price === 'number'
                ? a.price
                : typeof a?.delta === 'number'
                  ? a.delta
                  : 0;
          return {
            ...a,
            label,
            value,
            priceDelta,
            group: (a?.group || 'upgrade').toString(),
            key: (a?.key || a?.slug || a?.id || label || 'upgrade').toString(),
          };
        })
    : [];
  customs = Array.isArray(customs) ? customs.filter(Boolean) : [];
  // Map Sanity customPaint object -> a custom text input with optional surcharge
  const cp = (product as any).customPaint;
  if (cp?.enabled) {
    customs = Array.isArray(customs) ? customs.slice() : [];
    customs.push({
      key: 'paintCode',
      name: 'paintCode',
      label: cp.codeLabel || 'OEM Paint Code',
      placeholder: '',
      group: 'customPaint',
      type: 'text',
      required: cp.paintCodeRequired === true,
      priceDelta: typeof cp.additionalPrice === 'number' ? cp.additionalPrice : 0,
      instructions: cp.instructions || ''
    });
  }
  // SEO helpers
  seoTitle = baseProductTitle;
  plainDescription = collapseSpaces(
    toPlainText((product as any)?.shortDescription ?? (product as any)?.description ?? '')
  );
  seoCanon = defaultCanonical;
  seoOg = ensureAbsoluteUrl(
    (product as any)?.images?.[0]?.asset?.url || (product as any)?.images?.[0]?.url || undefined
  );
} catch (err) {
  console.error('❌ Failed to fetch product or similar products:', err);
  product = null;
}

const productNotFound = !product;
if (!product) {
  Astro.response.status = 404;
}

type AccordionSectionId = 'product-details' | 'key-features' | 'specs' | 'faq';

type AccordionSection = {
  id: AccordionSectionId;
  title: string;
  defaultOpen?: boolean;
};

let productImages: ProcessedProductImage[] = [];
let metaKeywords = '';
let serviceDisclaimer = '';
let serviceDisclaimerTitle = '';
let priceValue: number | undefined;
let breadcrumbStructuredData: Record<string, any> | null = null;
let productStructuredData: Record<string, any> | null = null;
let relatedProductsStructuredData: Record<string, any> | null = null;
let upsellProductsStructuredData: Record<string, any> | null = null;
let isInstallOnly = false;
let isPerformanceParts = false;
let requiresVehicleDisclaimer = false;
let productHeading = baseProductTitle;
let productSubheading: string | null = null;
let headingInlineAttrs: Record<string, any> = inlineFieldAttrs('title');
let descriptionDescriptor: ContentDescriptor | null = null;
let whyChooseContent: ContentDescriptor | null = null;
let featuresContent: ContentDescriptor | null = null;
let importantNotesDescriptor: ContentDescriptor | null = null;
let installFitmentHighlights: { label: string; value: string }[] = [];
let compatibilityVehicles: VehicleCompat[] = [];
let specMetaRows: { label: string; value: string }[] = [];
let includedInKitItems: KitItem[] = [];
let analyticsPrimaryCtaParams = '{}';
let analyticsStickyCtaParams = '{}';
let faqEntries: FAQEntry[] = [];

const accordionSections: AccordionSection[] = [];

if (!productNotFound) {
  if (isContentDescriptor(descriptionDescriptor)) {
    accordionSections.push({
      id: 'product-details',
      title: 'Product Details',
      defaultOpen: false
    });
  }

  if (featuresContent || includedInKitItems.length > 0) {
    accordionSections.push({
      id: 'key-features',
      title: 'Key Features'
    });
  }

  const hasSpecsSection =
    installFitmentHighlights.length > 0 ||
    compatibilityVehicles.length > 0 ||
    Boolean(importantNotesDescriptor) ||
    specMetaRows.length > 0 ||
    (Array.isArray(product?.specifications) && product?.specifications.length > 0) ||
    (Array.isArray(product?.attributes) && product?.attributes.length > 0);

  if (hasSpecsSection) {
    accordionSections.push({
      id: 'specs',
      title: 'Specs'
    });
  }

  if (faqEntries.length > 0) {
    accordionSections.push({
      id: 'faq',
      title: 'FAQ'
    });
  }
}

const vehicleAvailabilityProperty = {
  '@type': 'PropertyValue',
  name: 'Vehicle availability',
  value: 'Vehicle not included with purchase'
};

if (product) {
  const metaKeywordTokens: string[] = [];
  const productTypeRaw = collapseSpaces(String((product as any)?.productType || ''));
  const categoryTitlesForTokens: string[] = [];
  if (Array.isArray((product as any)?.categories)) {
    (product as any).categories.forEach((category: any) => {
      if (category?.title) metaKeywordTokens.push(String(category.title));
      if (category?.title) categoryTitlesForTokens.push(String(category.title));
      if (category?.slug?.current) metaKeywordTokens.push(String(category.slug.current).replace(/[-_]/g, ' '));
      if (category?.slug?.current) {
        categoryTitlesForTokens.push(String(category.slug.current).replace(/[-_]/g, ' '));
      }
    });
  }

  const filterEntriesForKeywords: FilterEntry[] = Array.isArray((product as any)?.filters)
    ? (product as any).filters
    : [];
  const filterSlugsForFlags: string[] = [];
  filterEntriesForKeywords.forEach((entry) => {
    const entrySlug = normalizeFilterSlug(entry);
    if (entrySlug) filterSlugsForFlags.push(entrySlug);
    const labelValue = normalizeFilterLabel(entry, entrySlug);
    if (labelValue) metaKeywordTokens.push(labelValue);
  });

  const canonicalFilterSlugs: Set<string> = new Set<string>();
  filterSlugsForFlags.forEach((value) => {
    if (!value) return;
    canonicalFilterSlugs.add(value);
    canonicalFilterSlugs.add(value.replace(/_/g, '-'));
    canonicalFilterSlugs.add(value.replace(/[-_]/g, ''));
  });

  const shippingClassRaw = ((product as any)?.shippingClass || '').toString();
  const normalizedShippingClass = shippingClassRaw.toLowerCase().replace(/[^a-z0-9]/g, '');
  const computedInstallOnly =
    normalizedShippingClass.includes('installonly') ||
    canonicalFilterSlugs.has('installonly') ||
    canonicalFilterSlugs.has('install-only');
  const computedPerformanceParts =
    normalizedShippingClass === 'performanceparts' ||
    canonicalFilterSlugs.has('performanceparts') ||
    canonicalFilterSlugs.has('performance-parts');

  isInstallOnly = computedInstallOnly;
  isPerformanceParts = computedPerformanceParts;
  const normalizedCategoryTokens: string[] = categoryTitlesForTokens
    .map((value) => collapseSpaces(value).toLowerCase())
    .filter((value: string): value is string => Boolean(value));
  const productTypeSegments: string[] = productTypeRaw
    ? productTypeRaw
        .split('>')
        .map((segment: string) => collapseSpaces(segment).toLowerCase())
        .filter((segment: string): segment is string => Boolean(segment))
    : [];
  const normalizedFilterTokens: string[] = Array.from(canonicalFilterSlugs)
    .map((token: string) => collapseSpaces(token.replace(/[-_]/g, ' ')).toLowerCase())
    .filter((token: string): token is string => Boolean(token));

  requiresVehicleDisclaimer =
    isInstallOnly ||
    [...normalizedCategoryTokens, ...productTypeSegments, ...normalizedFilterTokens].some((token) =>
      VEHICLE_DISCLAIMER_KEYWORDS.some((keyword) => token.includes(keyword))
    );

  if (requiresVehicleDisclaimer) {
    serviceDisclaimer = isInstallOnly
      ? 'Professional installation service only. Vehicle not included.'
      : 'Performance package or components only. Vehicle not included.';
    serviceDisclaimerTitle = isInstallOnly ? 'Professional installation required' : 'Vehicle not included';
    plainDescription = ensureDisclaimerMessaging(plainDescription, serviceDisclaimer);
  } else {
    serviceDisclaimer = '';
    serviceDisclaimerTitle = '';
  }

  const categoryTokensForFitment = Array.isArray((product as any)?.categories)
    ? (product as any).categories
        .map((category: any) => [category?.title, category?.slug?.current].filter(Boolean).join(' '))
    : [];
  const fitmentPhrase = toTitleCase(
    deriveFitmentPhrase(product, plainDescription, [
      ...categoryTokensForFitment,
      ...metaKeywordTokens,
      ...filterSlugsForFlags
    ])
  );
  const primaryKeyword = derivePrimaryKeyword(
    product,
    baseProductTitle,
    categoryTitlesForTokens,
    productTypeSegments,
    normalizedFilterTokens,
    fitmentPhrase,
    metaKeywordTokens,
    isInstallOnly,
    isPerformanceParts
  );
  const benefitsSummary = deriveBenefitsSummary(product, plainDescription);
  const callToAction = deriveCallToAction(product, isInstallOnly, isPerformanceParts);

  const secondaryTitleParts = [fitmentPhrase, primaryKeyword].filter(Boolean);
  const assembledTitle = secondaryTitleParts.length
    ? [baseProductTitle, secondaryTitleParts.join(' '), 'FAS Motorsports']
        .filter(Boolean)
        .join(' | ')
    : `${baseProductTitle} | FAS Motorsports`;
  seoTitle = collapseSpaces(assembledTitle);

  const descriptionSegments: string[] = [];
  const fitmentAndKeyword = [fitmentPhrase, primaryKeyword].filter(Boolean).join(' ');
  if (fitmentAndKeyword) {
    descriptionSegments.push(fitmentAndKeyword);
  } else if (fitmentPhrase) {
    descriptionSegments.push(fitmentPhrase);
  } else if (primaryKeyword) {
    descriptionSegments.push(primaryKeyword);
  }
  if (benefitsSummary) descriptionSegments.push(benefitsSummary);
  if (callToAction) descriptionSegments.push(callToAction);
  descriptionSegments.push('F.A.S. Motorsports');
  if (requiresVehicleDisclaimer) {
    descriptionSegments.push('Vehicle not included.');
  }
  const computedMetaDescription = truncateForMeta(
    descriptionSegments.filter(Boolean).join(' '),
    META_DESCRIPTION_LIMIT
  );
  seoDesc = computedMetaDescription
    ? computedMetaDescription
    : truncateForMeta(`${baseProductTitle} ${META_DESCRIPTION_SUFFIX}`, META_DESCRIPTION_LIMIT);

  metaKeywords = Array.from(
    new Set(
      metaKeywordTokens
        .map((token) => collapseSpaces(String(token)))
        .filter((token) => token.length > 0)
    )
  ).join(', ');

  if (
    fitmentPhrase &&
    !metaKeywords.toLowerCase().includes(fitmentPhrase.toLowerCase())
  ) {
    metaKeywords = collapseSpaces([metaKeywords, fitmentPhrase].filter(Boolean).join(', '));
  }
  if (primaryKeyword && !metaKeywords.toLowerCase().includes(primaryKeyword.toLowerCase())) {
    metaKeywords = collapseSpaces([metaKeywords, primaryKeyword].filter(Boolean).join(', '));
  }

  const headingParts = [primaryKeyword, fitmentPhrase].filter(Boolean);
  const derivedHeading = collapseSpaces(headingParts.join(' '));
  productHeading = baseProductTitle;
  productSubheading = derivedHeading || null;
  headingInlineAttrs = inlineFieldAttrs('title');
  if (!productHeading) {
    productHeading = baseProductTitle;
  }

  const seoBenefitsDescriptor = describeContent((product as any)?.seo?.benefits, 'seo.benefits');
  const seoHighlightsDescriptor = describeContent((product as any)?.seo?.highlights, 'seo.highlights');
  const seoValuePropsDescriptor = describeContent((product as any)?.seo?.valueProps, 'seo.valueProps');
  const shortDescriptionDescriptor = describeContent(product?.shortDescription, 'shortDescription');
  descriptionDescriptor = describeContent(product?.description, 'description');
  importantNotesDescriptor = describeContent(product?.importantNotes, 'importantNotes');

  whyChooseContent = descriptionDescriptor;
  featuresContent =
    seoHighlightsDescriptor ?? seoValuePropsDescriptor ?? descriptionDescriptor ?? shortDescriptionDescriptor ?? null;

  const possibleFaqCollections = [
    (product as any)?.faqEntries,
    (product as any)?.faq,
    (product as any)?.faqs,
    (product as any)?.faqList,
    (product as any)?.faqBlocks,
    (product as any)?.faqSection
  ];
  const faqSource = possibleFaqCollections.find((value) => Array.isArray(value) && value.length > 0) as any[] | undefined;
  if (faqSource) {
    faqEntries = faqSource
      .map((entry: any, index: number) => {
        const question =
          collapseSpaces(
            [
              entry?.question,
              entry?.title,
              entry?.prompt,
              entry?.heading,
              entry?.label,
              entry?.q
            ]
              .map((value) => (typeof value === 'string' ? value : ''))
              .find((value) => value.trim()) ?? ''
          ) || '';
        if (!question) return null;
        const answerValue =
          entry?.answer ??
          entry?.response ??
          entry?.a ??
          entry?.content ??
          entry?.body ??
          entry?.copy ??
          entry?.description ??
          entry?.value ??
          null;
        const answerDescriptor = describeContent(
          answerValue,
          typeof entry?.answerField === 'string'
            ? entry.answerField
            : typeof entry?.field === 'string'
              ? `${entry.field}.answer`
              : undefined
        );
        if (!answerDescriptor) return null;
        return {
          question,
          answer: answerDescriptor
        } satisfies FAQEntry;
      })
      .filter((entry): entry is FAQEntry => Boolean(entry));
  }

  const altFallback = collapseSpaces(
    [productHeading, productSubheading, 'F.A.S. Motorsports'].filter(Boolean).join(' ')
  );
  const normalizedImageSlugSource = slugValue || baseProductTitle;
  normalizedImageSlug = slugify(normalizedImageSlugSource);
  const imageEntries = Array.isArray((product as any)?.images) ? (product as any).images : [];
  productImages = imageEntries
    .map((image: any, index: number) => {
      const rawUrl = ensureAbsoluteUrl(image?.asset?.url || image?.url);
      if (!rawUrl) return null;
      const dimensions = (image?.asset as any)?.metadata?.dimensions ?? {};
      const width = typeof dimensions?.width === 'number' ? Math.round(dimensions.width) : undefined;
      const height = typeof dimensions?.height === 'number' ? Math.round(dimensions.height) : undefined;
      const aspectRatio =
        typeof dimensions?.aspectRatio === 'number'
          ? Number(dimensions.aspectRatio)
          : width && height
            ? width / height
            : undefined;
      const variant = index === 0 ? 'main' : `gallery-${index}`;
      const fileName = toSeoFileName(normalizedImageSlug, variant);
      const optimized = optimizeSanityImageUrl(rawUrl, { width: 1600, quality: 72, format: 'webp' }) || rawUrl;
      const optimizedThumb =
        optimizeSanityImageUrl(rawUrl, { width: 480, quality: 72, format: 'webp' }) || optimized;
      const webpUrl = withDownloadFileName(optimized, fileName);
      const thumbFileName = fileName.replace(/\.webp$/i, '-thumb.webp');
      const thumbnailUrl = withDownloadFileName(optimizedThumb, thumbFileName);
      return {
        originalUrl: rawUrl,
        webpUrl,
        thumbnailUrl,
        alt: buildProductImageAlt(image?.alt, altFallback, index),
        fileName,
        width,
        height,
        aspectRatio
      } satisfies ProcessedProductImage;
    })
    .filter(
      (value: ProcessedProductImage | null): value is ProcessedProductImage => Boolean(value)
    );

  if (!productImages.length) {
    const fallbackUrl = ensureAbsoluteUrl('/logo/faslogochroma.webp') ?? '/logo/faslogochroma.webp';
    const fallbackFile = toSeoFileName(normalizedImageSlug, 'placeholder');
    productImages = [
      {
        originalUrl: fallbackUrl,
        webpUrl: fallbackUrl,
        thumbnailUrl: fallbackUrl,
        alt: collapseSpaces(`${altFallback || baseProductTitle} placeholder image | F.A.S. Motorsports`),
        fileName: fallbackFile,
        width: 1200,
        height: 900,
        aspectRatio: 4 / 3
      }
    ];
  }

  if (!seoOg && productImages.length > 0) {
    seoOg = productImages[0].webpUrl;
  }

  const fitmentYearsText = collapseSpaces(
    [
      toPlainText((product as any)?.fitmentYears),
      toPlainText((product as any)?.seo?.fitmentYears)
    ]
      .filter(Boolean)
      .join(' ')
  );
  const fitmentRangeText = collapseSpaces(toPlainText((product as any)?.fitmentRange));
  const fitmentText = collapseSpaces(
    [
      toPlainText((product as any)?.fitment),
      toPlainText((product as any)?.seo?.fitment),
      toPlainText((product as any)?.seo?.fitmentText)
    ]
      .filter(Boolean)
      .join(' ')
  );

  installFitmentHighlights = [];
  if (fitmentYearsText) installFitmentHighlights.push({ label: 'Fitment Years', value: fitmentYearsText });
  if (fitmentText) installFitmentHighlights.push({ label: 'Fitment', value: fitmentText });
  if (fitmentRangeText && !installFitmentHighlights.some((item) => item.label === 'Fitment Range')) {
    installFitmentHighlights.push({ label: 'Fitment Range', value: fitmentRangeText });
  }
  if (isInstallOnly) {
    installFitmentHighlights.push({ label: 'Service Type', value: 'Professional install service only' });
  }

  compatibilityVehicles = Array.isArray((product as any)?.compatibleVehicles)
    ? (product as any).compatibleVehicles.filter(Boolean)
    : [];

  specMetaRows = [];
  const pushSpecMeta = (label: string, value: unknown, formatter?: (value: unknown) => string) => {
    if (value === undefined || value === null) return;
    const text = formatter ? formatter(value) : collapseSpaces(toPlainText(value));
    if (text) {
      specMetaRows.push({ label, value: text });
    }
  };

  pushSpecMeta(
    'Average Horsepower',
    typeof (product as any)?.averageHorsepower === 'number' ? (product as any)?.averageHorsepower : undefined,
    (value) => `${value}`
  );
  pushSpecMeta(
    'Shipping Weight',
    typeof (product as any)?.shippingWeight === 'number' ? (product as any)?.shippingWeight : undefined,
    (value) => `${value} lbs`
  );
  pushSpecMeta('Tune', (product as any)?.tune?.title);

  includedInKitItems = Array.isArray(product?.includedInKit)
    ? (product?.includedInKit as KitItem[]).filter(Boolean)
    : [];

  priceValue = typeof productPriceNumber === 'number' ? productPriceNumber : undefined;

  const analyticsBase = {
    product_id: typeof (product as any)?._id === 'string' ? (product as any)._id : undefined,
    product_name: baseProductTitle,
    product_slug: slug,
    price: typeof priceValue === 'number' ? Number(priceValue.toFixed(2)) : undefined,
    install_only: isInstallOnly,
    performance_parts: isPerformanceParts
  };
  analyticsPrimaryCtaParams = buildAnalyticsParams({
    ...analyticsBase,
    cta_location: 'primary_form'
  });
  analyticsStickyCtaParams = buildAnalyticsParams({
    ...analyticsBase,
    cta_location: 'sticky_bar'
  });

  breadcrumbStructuredData = {
    '@context': 'https://schema.org',
    '@type': 'BreadcrumbList',
    itemListElement: [
      { '@type': 'ListItem', position: 1, name: 'Home', item: requestUrl.origin },
      { '@type': 'ListItem', position: 2, name: 'Shop', item: `${requestUrl.origin}/shop` },
      { '@type': 'ListItem', position: 3, name: seoTitle, item: seoCanon }
    ]
  };

  const offerDetails: Record<string, any> = {
    '@type': 'Offer',
    priceCurrency: 'USD',
    availability: 'https://schema.org/InStock',
    url: seoCanon,
    itemCondition: 'https://schema.org/NewCondition',
    price: typeof priceValue === 'number' ? priceValue.toFixed(2) : undefined
  };

  const productSchemaImages = productImages.map((img) => img.webpUrl).filter(Boolean);

  productStructuredData = {
    '@context': 'https://schema.org',
    '@type': 'Product',
    name: (product as any)?.title,
    image: productSchemaImages.length ? productSchemaImages : undefined,
    description: plainDescription || undefined,
    url: seoCanon,
    offers: offerDetails
  };
  if (requiresVehicleDisclaimer) {
    productStructuredData.additionalProperty = [vehicleAvailabilityProperty];
  }
  productStructuredData.category = metaKeywords || undefined;
} else {
  seoTitle = 'Product Not Found';
  seoDesc = truncateForMeta(
    'The product you are looking for may have been removed or is no longer available. '
      + META_DESCRIPTION_SUFFIX,
    META_DESCRIPTION_LIMIT
  );
  seoCanon = defaultCanonical;
  productImages = [];
  metaKeywords = '';
  serviceDisclaimer = '';
  serviceDisclaimerTitle = '';
  priceValue = undefined;
  breadcrumbStructuredData = {
    '@context': 'https://schema.org',
    '@type': 'BreadcrumbList',
    itemListElement: [
      { '@type': 'ListItem', position: 1, name: 'Home', item: requestUrl.origin },
      { '@type': 'ListItem', position: 2, name: 'Shop', item: `${requestUrl.origin}/shop` },
      { '@type': 'ListItem', position: 3, name: 'Product Not Found', item: seoCanon }
    ]
  };
  productStructuredData = null;
}

relatedProductsStructuredData = buildProductListStructuredData(relatedProducts, 'Related products');
upsellProductsStructuredData = buildProductListStructuredData(upsellProducts, 'Recommended upgrades');
---

{!productNotFound ? (
  <BaseLayout title={seoTitle} description={seoDesc} canonical={seoCanon} ogImage={seoOg}>
  <Fragment slot="head">
    <meta property="og:type" content="product" />
    {typeof priceValue === 'number' && (
      <>
        <meta property="product:price:amount" content={priceValue.toFixed(2)} />
        <meta property="product:price:currency" content="USD" />
      </>
    )}
    <meta property="product:availability" content="https://schema.org/InStock" />
    {metaKeywords && <meta name="keywords" content={metaKeywords} />}
    {breadcrumbStructuredData && (
      <script type="application/ld+json" set:html={JSON.stringify(breadcrumbStructuredData)} />
    )}
    {productStructuredData && (
      <script type="application/ld+json" set:html={JSON.stringify(productStructuredData)} />
    )}
    {relatedProductsStructuredData && (
      <script type="application/ld+json" set:html={JSON.stringify(relatedProductsStructuredData)} />
    )}
    {upsellProductsStructuredData && (
      <script type="application/ld+json" set:html={JSON.stringify(upsellProductsStructuredData)} />
    )}
  </Fragment>
  <div {...inlineObjectId((product as any)._id)}>
  <div class="container mx-auto px-10 py-10 text-white" style="padding-top: 80px;">
    <div class="grid grid-cols-1 md:grid-cols-2 gap-10">
      <!-- LEFT: Sticky Image on desktop -->
      <div class="md:sticky md:top-28 flex justify-center items-start z-0 min-w-0" {...inlineFieldAttrs('images')}>
        <SlugCarousel images={productImages} useOptimizedImages={useOptimizedImages} />
      </div>

      <!-- RIGHT: Title, price, short intro, add-to-cart, then accordion -->
      <div class="relative z-10 min-w-0 break-words text-sm">
        <h1 class="text-3xl font-ethno mb-2" {...headingInlineAttrs}>{productHeading}</h1>
        {productSubheading && (
          <p class="text-xs uppercase tracking-[0.5em] text-white/60 mb-4">
            {productSubheading}
          </p>
        )}
        <h2 class="text-4xl text-accent
         font-mono mb-4" {...inlineFieldAttrs('price')}>
          {typeof priceValue === 'number' ? `$${priceValue.toFixed(2)}` : 'Price not available'}
        </h2>

        {(serviceDisclaimer || isContentDescriptor(importantNotesDescriptor)) && (
          <div class="mb-4">
            <ServiceDisclaimerNotice
              client:load
              message={serviceDisclaimer || 'Important information for this package.'}
              title={serviceDisclaimerTitle || 'Important information'}
              importantNotes={importantNotesDescriptor}
            />
          </div>
        )}

        <!-- Short intro (truncated) -->
        <div class="break-words" {...inlineFieldAttrs('shortDescription')}>
          <PortableTextRenderer value={product?.shortDescription ?? []} />
        </div>

        {(((options?.length || 0) + (addOns?.length || 0) + (customs?.length || 0)) > 0) && (
          <form id="product-options" class="mb-6 space-y-4">
            {/* Variant Options (radio/select) */}
            {Array.isArray(options) && options.length > 0 && options.filter(Boolean).map((group: any) => {
              const groupKey = (group?.key || group?.name || group?.title || 'option').toString();
              const values = Array.isArray(group?.values) ? group.values : (Array.isArray(group?.items) ? group.items : []);
              return (
                <div class="rounded-xl border border-white/15 bg-black/30 p-4">
                  <div class="text-sm font-semibold text-white">{group?.title || group?.name || 'Option'}</div>
                  {/* Prefer select if many values, else radios */}
                  {values.length > 4 ? (
                    <select
                      class="w-full border border-white/20 bg-black rounded px-2 py-2"
                      name={groupKey}
                      data-group={groupKey}
                    >
                      {values.map((v: any) => {
                        const val = typeof v === 'string' ? v : (v?.value || v?.name || v?.title || v?.label || '').toString();
                        const label = typeof v === 'string' ? v : (v?.label || v?.title || v?.name || v?.value || 'Choice');
                        const price = typeof v === 'object'
                          ? (typeof v?.priceDelta === 'number'
                              ? v.priceDelta
                              : (typeof v?.delta === 'number' ? v.delta : (typeof v?.price === 'number' ? v.price : 0)))
                          : 0;
                        return (
                          <option value={val} data-price={price.toString()} data-label={label}>
                            {label}
                            {price ? ` (+$${Number(price).toFixed(2)})` : ''}
                          </option>
                        );
                      })}
                    </select>
                  ) : (
                    <fieldset class="mt-4">
                      <div class="space-y-4 sm:flex sm:flex-wrap sm:items-center sm:gap-6">
                        {values.map((v: any, i: number) => {
                          const val = typeof v === 'string' ? v : (v?.value || v?.name || v?.title || v?.label || '').toString();
                          const label = typeof v === 'string' ? v : (v?.label || v?.title || v?.name || v?.value || 'Choice');
                          const price = typeof v === 'object'
                            ? (typeof v?.priceDelta === 'number'
                                ? v.priceDelta
                                : (typeof v?.delta === 'number' ? v.delta : (typeof v?.price === 'number' ? v.price : 0)))
                            : 0;
                          const inputId = `${groupKey}-${i}`;
                          return (
                            <div class="flex items-center">
                              <input
                                type="radio"
                                name={groupKey}
                                value={val}
                                data-group={groupKey}
                                data-price={price}
                                data-label={label}
                                checked={i === 0}
                                id={inputId}
                                class="relative h-4 w-4 appearance-none rounded-full border border-white/15 bg-white/5 before:absolute before:inset-1 before:rounded-full before:bg-white before:opacity-0 before:transition checked:border-amber-500 checked:bg-amber-500 checked:before:opacity-100 focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-amber-500"
                              />
                              <label for={inputId} class="ml-3 flex flex-col text-sm font-medium text-white cursor-pointer">
                                <span class="leading-snug">{label}</span>
                                <span class="text-xs font-semibold text-white/60">
                                  {price ? `+$${Number(price).toFixed(2)}` : ''}
                                </span>
                              </label>
                            </div>
                          );
                        })}
                      </div>
                    </fieldset>
                  )}
                </div>
              );
            })}

            {isContentDescriptor(descriptionDescriptor) && (
          <details class="group mt-4 rounded-xl border border-white/10 bg-black/30 text-white/90 shadow-inner" >
            <summary class="flex cursor-pointer select-none items-center justify-between rounded-t-xl bg-black/40 px-4 py-3 font-ethno text-base md:text-lg">
              <span>Product Details</span>
              <span class="transition-transform group-open:rotate-180">▾</span>
            </summary>
            <div class="px-4 py-4 leading-relaxed break-words font-arial whitespace-pre-line" {...inlineFieldAttrs('description')}>
              {descriptionDescriptor.type === 'portable' ? (
                <PortableTextRenderer value={descriptionDescriptor.value as any[]} />
              ) : (
                <p class="mb-0">{descriptionDescriptor.value as string}</p>
              )}
            </div>
          </details>
        )}

            {/* Add-ons (checkbox) */}
            {Array.isArray(addOns) && addOns.length > 0 && (
              <div class="p-3">
                <div class="font-semibold mb-2">Upgrades</div>
                <div class="grid grid-auto-fit-220 gap-2">
                  {addOns.map((a: any) => (
                    <label class="relative flex items-center gap-3 rounded-md border border-white/30 shadow shadow-md shadow-white/10 bg-black/40 px-3 py-2 text-white transition hover:border-white/50 hover:bg-black/55 focus-within:border-white/70 focus-within:ring-1 focus-within:ring-white/40 cursor-pointer content-block">
                      <input type="checkbox"
                        name={(a.key || 'upgrade').toString()}
                        value={(a.value || a.label || '').toString()}
                        data-group={(a.group || 'upgrade').toString()}
                        data-price={(typeof a.priceDelta === 'number' ? a.priceDelta : 0).toString()}
                        data-label={a.label}
                        checked={!!a.defaultSelected}
                        class="h-4 w-4 flex-shrink-0 accent-primary bg-black focus:ring-0"
                      />
                      <span class="flex-1 text-sm font-medium leading-snug text-white break-words">{a.label}</span>
                      <span class="ml-3 text-xs font-semibold text-white/70">
                        {typeof a.priceDelta === 'number' && a.priceDelta !== 0
                          ? `+$${Number(a.priceDelta).toFixed(2)}`
                          : ''}
                      </span>
                    </label>
                  ))}
                </div>
              </div>
            )}

            {/* Custom fields (e.g., paint code with fixed surcharge) */}
            {Array.isArray(customs) && customs.length > 0 && customs.map((c: any) => (
              <div class="bg-black/20 rounded-none p-3 border border-white/20">
                <div class="font-semibold mb-2">{c.label || c.title || 'Custom Option'}</div>
                <input
                  type={c.type === 'number' ? 'number' : 'text'}
                  name={(c.key || c.name || 'custom').toString()}
                  placeholder={(c.placeholder || '').toString()}
                  class="w-full bg-black/30 border border-white/20 rounded px-2 py-2"
                  data-group={(c.group || 'custom').toString()}
                  data-price={(typeof c.priceDelta === 'number' ? c.priceDelta : (typeof c.price === 'number' ? c.price : (typeof c.delta === 'number' ? c.delta : 0))).toString()}
                  required={!!c.required}
                />
                {c.instructions && (
                  <div class="mt-1 text-xs opacity-80">{String(c.instructions)}</div>
                )}
                {(typeof c.priceDelta === 'number' || typeof c.price === 'number' || typeof c.delta === 'number') && (
                  <div class="mt-1 text-xs opacity-70">Surcharge: +${Number(c.priceDelta ?? c.price ?? c.delta ?? 0).toFixed(2)}</div>
                )}
              </div>
            ))}

            {/* Live price & Add to Cart */}
            <div class="mt-6 flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
              <div class="flex flex-1 items-center justify-between rounded-lg border border-white/20 bg-black/20 px-3 py-3">
                <span class="text-sm opacity-80">Configured Price</span>
                <span id="price-total" class="text-lg font-bold">
                  $ {(typeof (product as any).price === 'number' ? (product as any).price.toFixed(2) : '0.00')}
                </span>
              </div>

              <button
                id="add-to-cart-btn"
                type="button"
                class="add-to-cart hidden md:inline-flex items-center gap-2 border border-white/30 px-4 py-2 rounded-full hover:bg-primary hover:text-white transition relative z-10 pointer-events-auto sm:w-auto"
                data-product-id={(product as any)._id}
                data-product-name={(product as any).title}
                data-product-price={typeof priceValue === 'number' ? priceValue.toFixed(2) : undefined}
                data-product-base-price={typeof priceValue === 'number' ? priceValue.toFixed(2) : undefined}
                data-product-image={productImages[0]?.webpUrl || productImages[0]?.originalUrl || ''}
                data-product-categories={`${JSON.stringify((product as any).categories || [])}`}
                data-product-shipping-class={(product as any).shippingClass || ''}
                data-product-install-only={String(isInstallOnly)}
                data-product-performance-parts={String(isPerformanceParts)}
                data-product-href={`/shop/${slug}`}
                data-analytics-event="add_to_cart_click"
                data-analytics-category="ecommerce"
                data-analytics-label={`Add to Cart | ${baseProductTitle}`}
                data-analytics-params={analyticsPrimaryCtaParams}
              >
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5">
                  <path d="M8 7a4 4 0 118 0h3a1 1 0 011 1v12a2 2 0 01-2 2H6a2 2 0 01-2-2V8a1 1 0 011-1h3zm2 0a2 2 0 104 0H10z" />
                </svg>
                <span class="text-sm font-kwajong">Add to Cart</span>
              </button>
            </div>
          </form>
        )}
        <!-- Optional media strip (images/videos/files from Sanity "media" field) -->
        {Array.isArray((product as any)?.media) && (product as any).media.length > 0 && (
          <section class="mt-6">
            <h3 class="font-semibold mb-2">Media</h3>
            <div class="flex gap-3 overflow-x-auto pb-2">
              {(product as any).media.map((m: any, mediaIndex: number) => {
                try {
                  const title = String(m?.title || '').trim();
                  const alt = String(m?.alt || title || (product as any)?.title || 'Media');
                  const assetUrl = (m?.asset && (m.asset.url || (m.asset as any)?.asset?.url)) || '';
                  const directUrl = String(m?.url || '') || '';
                  const url = assetUrl || directUrl;
                  const playbackId = String(m?.muxPlaybackId || (m?.asset && (m.asset as any)?.playbackId) || '').trim();
                  let yt = String(m?.youTubeId || m?.youtubeId || '').trim();

                  // Heuristics
                  const isImage = /\.(?:jpe?g|png|gif|webp|avif|svg)(?:\?.*)?$/i.test(url);
                  const isVideoFile = /\.(?:mp4|webm|ogg)(?:\?.*)?$/i.test(url);

                  // If a YouTube link is provided via url, extract the ID
                  if (!yt && /(?:youtu\.be\/.+|youtube\.com\/.+)/i.test(url)) {
                    try {
                      const u = new URL(url, typeof window !== 'undefined' ? window.location.origin : 'https://example.com');
                      if (/youtu\.be/i.test(u.hostname)) {
                        yt = u.pathname.replace(/^\//, '').split('/')[0];
                      } else if (/youtube\.com/i.test(u.hostname)) {
                        if (u.pathname.includes('/embed/')) yt = u.pathname.split('/embed/')[1]?.split(/[?&#]/)[0] || '';
                        else yt = u.searchParams.get('v') || '';
                      }
                    } catch {}
                  }

                  if (playbackId) {
                    const muxMp4 = `https://stream.mux.com/${playbackId}/medium.mp4`;
                    return (
                      <video controls preload="metadata" class="w-64 h-36 rounded border border-white/20 bg-black/30" src={muxMp4}></video>
                    );
                  }
                  if (yt) {
                    const src = `https://www.youtube.com/embed/${yt}`;
                    return (
                      <iframe
                        src={src}
                        title={alt}
                        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                        allowfullscreen
                        class="w-64 h-36 rounded border border-white/20 bg-black/30"
                      />
                    );
                  }
                  if (isVideoFile) {
                    return (
                      <video controls preload="metadata" class="w-64 h-36 rounded border border-white/20 bg-black/30" src={url}></video>
                    );
                  }
                  if (isImage) {
                    const mediaFileName = toSeoFileName(normalizedImageSlug, `media-${mediaIndex + 1}`);
                    const optimizedMedia = optimizeSanityImageUrl(url, {
                      width: 1024,
                      quality: 70,
                      format: 'webp'
                    }) || url;
                    const optimizedThumb = optimizeSanityImageUrl(url, {
                      width: 480,
                      quality: 70,
                      format: 'webp'
                    }) || optimizedMedia;
                    const mediaUrl = withDownloadFileName(optimizedMedia, mediaFileName);
                    const thumbUrl = withDownloadFileName(
                      optimizedThumb,
                      mediaFileName.replace(/\.webp$/i, '-thumb.webp')
                    );
                    return useOptimizedImages ? (
                      <AstroImage
                        src={mediaUrl}
                        alt={alt}
                        width={640}
                        height={360}
                        format="webp"
                        quality={70}
                        loading="lazy"
                        decoding="async"
                        fit="cover"
                        class="w-64 h-36 object-cover rounded border border-white/20 bg-black/30"
                        sizes="256px"
                        data-thumb={thumbUrl}
                      />
                    ) : (
                      <img
                        src={mediaUrl}
                        alt={alt}
                        width={640}
                        height={360}
                        loading="lazy"
                        decoding="async"
                        class="w-64 h-36 object-cover rounded border border-white/20 bg-black/30"
                        data-thumb={thumbUrl}
                      />
                    );
                  }
                  if (url) {
                    return (
                      <a href={url} target="_blank" rel="noopener" class="w-64 h-36 grid place-items-center rounded border border-white/20 bg-black/20 text-sm underline">
                        View media
                      </a>
                    );
                  }
                } catch {}
                return null;
              })}
            </div>
          </section>
        )}

  

        <!-- Categories and Filters -->

          {(((product as any).categories?.length ?? 0) > 0) || (((product as any).filters?.length ?? 0) > 0) ? (
            <div class="text-left text-sm text-white/70">
              {(product as any).categories?.length > 0 && (
                <div class="mb-1 mt-10">
                  <span class="font-semibold text-white">Categories:</span>{' '}
                  {(product as any).categories.map((c: any, idx: number) => (
                    <>
                      <a href={`/shop?categorySlug=${c.slug?.current || c.slug}`} class="hover:underline">
                        {c.title}
                      </a>
                      {idx < (product as any).categories.length - 1 ? ', ' : ''}
                    </>
                  ))}
                </div>
              )}
              {(product as any).filters?.length > 0 && (
                <div>
                  <span class="font-semibold text-white">Filters:</span>{' '}
                  {(() => {
                    const filterEntries: FilterEntry[] = Array.isArray((product as any).filters)
                      ? (product as any).filters
                      : [];
                    const titleEntries: FilterEntry[] = Array.isArray((product as any).filterTitles)
                      ? (product as any).filterTitles
                      : filterEntries;
                    const pairs = filterEntries
                      .map((entry, idx) => {
                        const slug = normalizeFilterSlug(entry);
                        if (!slug) return null;
                        const label = normalizeFilterLabel(titleEntries[idx] ?? entry, slug);
                        if (!label) return null;
                        return { slug, label };
                      })
                      .filter(Boolean);

                    return pairs.map((item, idx) => (
                      item ? (
                        <>
                          <a href={`/shop?filters=${encodeURIComponent(item.slug)}`} class="hover:underline capitalize">
                            {item.label}
                          </a>
                          {idx < pairs.length - 1 ? ', ' : ''}
                        </>
                      ) : null
                    ));
                  })()}
                </div>
              )}
            </div>
          ) : null}
        </div>
      </div>
    </div>

    <section class="mt-6 w-3/4 mx-auto px-15">
      <InfoTabs
        client:load
        kitItems={includedInKitItems}
        keyFeatures={(product as any)?.keyFeatures}
        specifications={(product as any)?.specifications}
        attributes={(product as any)?.attributes}
      />
    </section>

    <!-- Related Products -->
{Array.isArray(relatedProducts) && relatedProducts.length > 0 && (
  <div class="mt-16 mx-auto px-20 mb-10">
    <h2 class="text-2xl text-accent font-ethno mb-6">Related Products</h2>
    <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
      {(relatedProducts || [])
        .filter((p: any) => p && p.slug && (p.slug.current || typeof p.slug === 'string'))
        .map((p: any) => {
          const s = (p.slug && (p.slug.current || p.slug)) as string;
          if (!s) return null;
          const img = p?.images?.[0]?.asset?.url || '/logo/faslogochroma.webp';
          const alt = p?.images?.[0]?.alt || p?.title || 'Product image';
          const price =
            typeof p?.price === 'number' ? `$${p.price.toFixed(2)}` : '';
          return (
            <>
              {p.slug?.current ? (
                <a href={`/shop/${p.slug.current}`} class="block bg-black/10 rounded-lg shadow-md hover:shadow-lg transition p-4">
                  <div class="w-full aspect-square bg-black/20 rounded-md mb-4 overflow-hidden grid place-items-center">
                    <img src={img} alt={alt} class="max-w-full max-h-full object-contain" />
                  </div>
                  <h3 class="text-lg font-semibold">{p?.title || 'Untitled product'}</h3>
                  <p class="text-primary font-bold">{price}</p>
                </a>
              ) : (
                <span class="block bg-black/10 rounded-lg shadow-md transition p-4">
                  <div class="w-full aspect-square bg-black/20 rounded-md mb-4 overflow-hidden grid place-items-center">
                    <img src={img} alt={alt} class="max-w-full max-h-full object-contain" />
                  </div>
                  <h3 class="text-lg font-semibold">{p?.title || 'Untitled product'}</h3>
                  <p class="text-primary font-bold">{price}</p>
                </span>
              )}
            </>
          );
        })}
    </div>
  </div>
)}

<!-- Recommended Upgrades / Upsell -->
{Array.isArray(upsellProducts) && upsellProducts.length > 0 && (
  <div class="hidden mt-12 mx-auto px-20">
    <h2 class="text-2xl text-accent font-ethno mb-6">Recommended Upgrades</h2>
    <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
      {(upsellProducts || [])
        .filter((p: any) => p && p.slug && (p.slug.current || typeof p.slug === 'string'))
        .map((p: any) => {
          const s = (p.slug && (p.slug.current || p.slug)) as string;
          if (!s) return null;
          const img = p?.images?.[0]?.asset?.url || '/logo/faslogochroma.webp';
          const alt = p?.images?.[0]?.alt || p?.title || 'Product image';
          const price =
            typeof p?.price === 'number' ? `$${p.price.toFixed(2)}` : '';
          return (
            <>
              {p.slug?.current ? (
                <a href={`/shop/${p.slug.current}`} class="block bg-black/10 rounded-lg shadow-md hover:shadow-lg transition p-4">
                  <div class="w-full aspect-square bg-black/20 rounded-md mb-4 overflow-hidden grid place-items-center">
                    <img src={img} alt={alt} class="max-w-full max-h-full object-contain" />
                  </div>
                  <h3 class="text-lg font-semibold">{p?.title || 'Untitled product'}</h3>
                  <p class="text-primary font-bold">{price}</p>
                </a>
              ) : (
                <span class="block bg-black/10 rounded-lg shadow-md transition p-4">
                  <div class="w-full aspect-square bg-black/20 rounded-md mb-4 overflow-hidden grid place-items-center">
                    <img src={img} alt={alt} class="max-w-full max-h-full object-contain" />
                  </div>
                  <h3 class="text-lg font-semibold">{p?.title || 'Untitled product'}</h3>
                  <p class="text-primary font-bold">{price}</p>
                </span>
              )}
            </>
          );
        })}
    </div>
  </div>
)}
  </div>
  </div>

  
  </BaseLayout>
<!-- Sticky mobile add-to-cart bar -->
<div id="mobile-add-to-cart" class="md:hidden fixed bottom-0 left-0 right-0 z-[60] bg-black/90 border-t border-white/20 backdrop-blur px-3 py-2 flex items-center justify-between">
  <div class="text-white/90 text-sm w-1/2">
    <span class="text-white/70">Total:</span>
    <span id="sticky-price" class="font-bold">$ {(typeof (product as any).price === 'number' ? (product as any).price.toFixed(2) : '0.00')}</span>
  </div>
  <button
    type="button"
    class="add-to-cart inline-flex items-center gap-2 bg-primary text-white font-ethno px-4 py-2 rounded hover:text-white btn-glass w-1/2"
    data-product-id={(product as any)._id}
    data-product-name={(product as any).title}
    data-product-price={typeof priceValue === 'number' ? priceValue.toFixed(2) : undefined}
    data-product-base-price={typeof priceValue === 'number' ? priceValue.toFixed(2) : undefined}
    data-product-image={(product as any).images?.[0]?.asset?.url || (product as any).images?.[0]?.url || ''}
    data-product-categories={`${JSON.stringify((product as any).categories || [])}`}
    data-product-shipping-class={(product as any).shippingClass || ''}
    data-product-install-only={String(
      ((product as any).shippingClass || '').toString().toLowerCase().replace(/[^a-z]/g, '') ===
        'installonly'
    )}
    data-product-href={`/shop/${slug}`}
    data-analytics-event="add_to_cart_click"
    data-analytics-category="ecommerce"
    data-analytics-label={`Sticky Add to Cart | ${baseProductTitle}`}
    data-analytics-params={analyticsStickyCtaParams}
  >
    Add to Cart
  </button>
</div>
</div>

  <!-- IMPORTANT: Do not reintroduce Astro.resolve/Astro2.resolve; use prebuilt URL import -->
  <script type="module" set:html={productPageScript} defer></script>

) : (
  <BaseLayout title={seoTitle} description={seoDesc} canonical={seoCanon}>
    <Fragment slot="head">
      {breadcrumbStructuredData && (
        <script type="application/ld+json" set:html={JSON.stringify(breadcrumbStructuredData)} />
      )}
    </Fragment>
    <section class="mx-auto flex min-h-[60vh] max-w-3xl flex-col items-center justify-center px-4 py-24 text-center text-white">
      <h1 class="text-4xl font-ethno md:text-5xl">Product not found</h1>
      <p class="mt-4 text-sm text-white/80 md:text-base">
        The product you are looking for may have been removed, renamed, or is temporarily unavailable.
      </p>
      <a
        class="mt-8 inline-flex items-center rounded-full border border-white/30 px-5 py-2 text-sm uppercase tracking-wide transition hover:bg-primary hover:text-white"
        href="/shop"
      >
        Browse all products
      </a>
    </section>
  </BaseLayout>
)}
  <style>
    /* Ensure transparent overlays don’t block clicks on this product page */
    [class~="absolute"][class~="inset-0"][class*="bg-black/10"][class~="z-0"] { pointer-events: none; }

    /* Make sure the right column (options) sits above the sticky image on desktop */
    @media (min-width: 768px) {
      .md\:sticky { z-index: 0; }
    }

    /* Raise interactive panels/forms */
    #product-options, #acc-details { position: relative; z-index: 10; }

    /* Safety: any full-bleed overlay divs should not eat clicks */
    [class~="absolute"][class~="inset-0"] { pointer-events: none; }
  </style>
