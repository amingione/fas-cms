---
import { Carousel } from "@/components/storefront/carousel";
import { sanityClient as client } from "@/lib/sanityClient";
import BaseLayout from "@/layouts/BaseLayout.astro";
import StoreHero from '@/components/storefront/StoreHero.astro';

// Choose which categories (by slug) to show on this page.
// Fill this list with the exact slugs you want featured. Leave empty to show all.
const chosenSlugs: string[] = [];

// Optional: Manually override category images here by slug.
// Example: 'porting': '/images/packages/porting-custom.webp'
const categoryImageOverrides: Record<string, string> = {
  'custom-coating': '/images/superchargers/2-7-dominator-package.webp',
  'porting': '/images/snouts/fas-ported-snout.webp',
  'supercharger-rebuild': '/images/superchargers/Suupercharger-New.webp'
};

// Base fields to select from categories
const categoryFields = `
  _id,
  title,
  "slug": slug.current,
  "imageUrl": image.asset->url,
  description
`;

// All visible categories
const categoriesQueryAll = /* groq */ `
*[_type == "category" && defined(slug.current)] | order(orderRank asc){
  ${categoryFields}
}`;

interface Category {
  _id: string;
  title: string;
  slug: string;
  imageUrl: string;
  description?: string;
}

// Fetch all categories for the grid
const categoriesAll: Category[] = await client.fetch(categoriesQueryAll);
// Optional: use chosenSlugs to build a curated subset elsewhere if needed
const featuredCategories: Category[] = chosenSlugs.length
  ? categoriesAll.filter((category) => chosenSlugs.includes(category.slug))
  : categoriesAll;

// Fetch featured products for the carousel (boolean true, then string "true" fallback)
let featuredRaw: any[] = [];
try {
  featuredRaw = await client.fetch(`*[_type == "product" && !(_id in path("drafts.**")) && coalesce(featured, false) == true && defined(slug.current)][0..11]{
    _id,
    name,
    title,
    "slug": slug.current,
    price,
    images[]{ asset->{ url } },
    // common fallbacks used elsewhere
    "imageUrl": coalesce(image.asset->url, mainImage.asset->url, images[0].asset->url, thumbnail.asset->url, thumb.asset->url)
  }`);
  if (!Array.isArray(featuredRaw) || featuredRaw.length === 0) {
    featuredRaw = await client.fetch(`*[_type == "product" && !(_id in path("drafts.**")) && featured == "true" && defined(slug.current)][0..11]{
      _id,
      name,
      title,
      "slug": slug.current,
      price,
      images[]{ asset->{ url } },
      "imageUrl": coalesce(image.asset->url, mainImage.asset->url, images[0].asset->url, thumbnail.asset->url, thumb.asset->url)
    }`);
  }
} catch (e) {
  console.error('Failed to fetch featured products for carousel', e);
  featuredRaw = [];
}

// Normalize to the shape expected by ProductCardLiteReact (images[0].asset.url)
const featuredProducts = (Array.isArray(featuredRaw) ? featuredRaw : []).map((p: any) => ({
  _id: p?._id,
  title: p?.title || p?.name || 'Product',
  slug: p?.slug,
  price: p?.price,
  images: Array.isArray(p?.images) && p.images.length
    ? p.images
    : (p?.imageUrl ? [{ asset: { url: p.imageUrl } }] : []),
  categories: p?.categories ?? []
}));


const requestUrl = new URL(Astro.request.url);
requestUrl.search = '';
requestUrl.hash = '';
const canonicalUrl = requestUrl.toString();
const pageTitle = 'Shop Categories';
const pageDescription = 'Browse performance categories curated by F.A.S. Motorsports to jumpstart your build path.';

const ensureAbsoluteUrl = (value?: string | null) => {
  if (!value) return undefined;
  if (/^https?:/i.test(value)) return value;
  try {
    return new URL(value, `${requestUrl.origin}/`).toString();
  } catch {
    return undefined;
  }
};

const breadcrumbStructuredData = {
  '@context': 'https://schema.org',
  '@type': 'BreadcrumbList',
  itemListElement: [
    { '@type': 'ListItem', position: 1, name: 'Home', item: `${requestUrl.origin}/` },
    { '@type': 'ListItem', position: 2, name: 'Shop Categories', item: canonicalUrl }
  ]
};

const categoryItemListElements = Array.isArray(categoriesAll)
  ? categoriesAll
      .map((category, index) => {
        if (!category?.slug) return null;
        const categoryUrl = `${requestUrl.origin}/shop/categories/${category.slug}`;
        const imageOverride = categoryImageOverrides[category.slug];
        const imageUrl = ensureAbsoluteUrl(imageOverride ?? category.imageUrl ?? undefined);
        return {
          '@type': 'ListItem',
          position: index + 1,
          url: categoryUrl,
          item: {
            '@type': 'CollectionPage',
            name: category.title ?? 'Category',
            url: categoryUrl,
            description: category.description ?? undefined,
            image: imageUrl ? [imageUrl] : undefined
          }
        };
      })
      .filter((entry): entry is Record<string, any> => Boolean(entry))
  : [];

const categoryCollectionStructuredData = categoryItemListElements.length
  ? {
      '@context': 'https://schema.org',
      '@type': 'CollectionPage',
      name: pageTitle,
      url: canonicalUrl,
      description: pageDescription,
      mainEntity: {
        '@type': 'ItemList',
        name: 'Performance categories',
        numberOfItems: categoryItemListElements.length,
        itemListElement: categoryItemListElements
      }
    }
  : null;

const featuredItemListElements = Array.isArray(featuredProducts)
  ? featuredProducts
      .map((product, index) => {
        if (!product?.slug) return null;
        const slugValue = typeof product.slug === 'string' ? product.slug : product.slug?.current;
        if (!slugValue) return null;
        const productUrl = `${requestUrl.origin}/shop/${slugValue}`;
        const images = Array.isArray(product.images)
          ? product.images
              .map((image: any) => ensureAbsoluteUrl(image?.asset?.url || image?.url))
              .filter((value): value is string => Boolean(value))
          : [];
        const priceNumber = Number(product.price);
        const offers = !Number.isNaN(priceNumber) && priceNumber > 0
          ? {
              '@type': 'Offer',
              priceCurrency: 'USD',
              price: priceNumber.toFixed(2),
              availability: 'https://schema.org/InStock',
              url: productUrl,
              itemCondition: 'https://schema.org/NewCondition'
            }
          : undefined;
        return {
          '@type': 'ListItem',
          position: index + 1,
          url: productUrl,
          item: {
            '@type': 'Product',
            name: product.title,
            image: images.length ? images : undefined,
            offers
          }
        };
      })
      .filter((entry): entry is Record<string, any> => Boolean(entry))
  : [];

const featuredProductsStructuredData = featuredItemListElements.length
  ? {
      '@context': 'https://schema.org',
      '@type': 'ItemList',
      name: 'Featured products',
      itemListElement: featuredItemListElements
    }
  : null;


const tileClass = (i: number) => {
  const base = "relative block h-full rounded-xl overflow-hidden border border-white/20 bg-black group";
  const small = "lg:col-span-2 lg:row-span-1";
  const large = "lg:col-span-4 lg:row-span-2";
  /**
   * Mosaic pattern (repeats every 7 items):
   * [L, S, S, S, S, S, L]
   * This yields a hero-like large tile at the start of each row block,
   * and another large tile at the end to balance the layout.
   */
  const pos = i % 7;
  const isLarge = pos === 0 || pos === 6;
  return `${base} ${isLarge ? large : small}`;
};
---
<BaseLayout title={pageTitle} description={pageDescription} canonical={canonicalUrl}>
  <Fragment slot="head">
    <script type="application/ld+json" set:html={JSON.stringify(breadcrumbStructuredData)} />
    {categoryCollectionStructuredData && (
      <script type="application/ld+json" set:html={JSON.stringify(categoryCollectionStructuredData)} />
    )}
    {featuredProductsStructuredData && (
      <script type="application/ld+json" set:html={JSON.stringify(featuredProductsStructuredData)} />
    )}
  </Fragment>
  <section class="mt-2 pt-4">
     <StoreHero
       ctaPrimaryLabel="Shop All Products âž¤"
       ctaPrimaryHref="/shop"
     />
    </section>

  <!-- CATEGORY MOSAIC GRID -->
  <section class="px-5 relative grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-6 grid-flow-dense gap-4 md:gap-6 auto-rows-[220px] mt-4 pt-4">
    {
      categoriesAll.map((c, i) => (
        <a href={`/shop/categories/${c.slug}`} class={tileClass(i)} aria-label={c.title}>
          <img
            src={categoryImageOverrides[c.slug] ?? (c.imageUrl ?? "/logo/faslogochroma.webp")}
            alt={c.title}
            class="h-full w-full object-contain transition-transform duration-300 group-hover:scale-105"
            loading="lazy"
            decoding="async"
          />
          <!-- dark gradient overlay -->
          <div class="pointer-events-none absolute inset-0 bg-gradient-to-t from-black/70 via-black/30 to-transparent" />
          <!-- label pill -->
          <div class="absolute left-3 bottom-3">
            <span class="rounded-full btn-glass border-white/30 px-3 py-1 text-xs uppercase tracking-wide text-white shadow">
              {c.title}
            </span>
            </div>
        </a>
      ))
    }
  </section>
   <!-- HERO / CAROUSEL -->
  <section class="mt-4 pt-4">
    <Carousel products={featuredProducts} images={featuredProducts.map(p => p.images)} speedSec={120} client:only="react" />
  </section>
</BaseLayout>
